package io.jenkins.plugins.portshift_vulnerability_scanner;

import com.cloudbees.plugins.credentials.CredentialsProvider;
import com.cloudbees.plugins.credentials.common.StandardListBoxModel;
import hudson.AbortException;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractProject;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.security.ACL;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import hudson.util.Secret;
import io.jenkins.DockerRiskSeverity;
import io.jenkins.VulnerabilitySeverity;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Base64;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import javax.annotation.Nonnull;
import javax.mail.search.SizeTerm;
import jenkins.model.Jenkins;
import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONObject;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.Symbol;
import org.jenkinsci.plugins.plaincredentials.StringCredentials;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;


public class PortshiftVulnerabilityScannerBuilder extends Builder implements SimpleBuildStep {

  protected static final String PLUGIN_NAME = "securecn-scanner";
  private static final String IMAGE_NAME_REGEX = "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$";
  private static final String IMAGE_TAG_REGEX = "\\S+"; //String of at least one character where all characters are non-whitespace

  private String accessKey;
  private String portshiftSecretKeyId;
  private String secretKey;
  private String imageName;
  private String imageTag;
  private String url;
  private String dockerRegistryPasswordId;
  private String dockerRegistryUsername;
  private String dockerRegistryPassword;
  private String highestSeverityAllowed;
  private String highestSeverityAllowedDf;

  @DataBoundConstructor
  public PortshiftVulnerabilityScannerBuilder(String accessKey, String portshiftSecretKeyId, String imageName,
      String imageTag, String url, String highestSeverityAllowed, String dockerRegistryUsername,
      String dockerRegistryPasswordId, String highestSeverityAllowedDf) {
    this.accessKey = accessKey;
    this.portshiftSecretKeyId = portshiftSecretKeyId;
    this.imageName = imageName;
    this.imageTag = imageTag;
    if (url.contains("://")) {
      this.url = url.split("://")[1];
    } else {
      this.url = url;
    }
    this.highestSeverityAllowed = highestSeverityAllowed;
    this.dockerRegistryUsername = dockerRegistryUsername;
    this.dockerRegistryPasswordId = dockerRegistryPasswordId;
    this.highestSeverityAllowedDf = highestSeverityAllowedDf;
  }

  public String getAccessKey() {
    return accessKey;
  }

  public String getSecretKey() {
    return secretKey;
  }

  public String getImageName() {
    return imageName;
  }

  public String getImageTag() {
    return imageTag;
  }

  public String getUrl() {
    return url;
  }

  public String getHighestSeverityAllowed() {
    return highestSeverityAllowed;
  }

  public String getDockerRegistryUsername() {
    return dockerRegistryUsername;
  }

  public String getHighestSeverityAllowedDf() {
    return highestSeverityAllowedDf;
  }

  @Override
  public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath workspace, @Nonnull Launcher launcher,
      @Nonnull TaskListener listener)
      throws AbortException {


    setSecrets();

    if (accessKey == null || secretKey == null || imageName == null || imageTag == null || url == null) {
      throw new AbortException(
          "Missing configuration. Please set the plugin configuration parameters before continuing.\n");
    }

    int exitCode = PortshiftVulnerabilityScanExecuter
        .execute(run, workspace, launcher, listener, accessKey, secretKey, imageName, imageTag, url,
            highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf);
    listener.getLogger().println("exitCode: " + exitCode);

    String failedMessage = "Vulnerability scan has failed.";
    switch (exitCode) {
      case 0:
        listener.getLogger().println("Vulnerability scan has completed successfully.");
        break;
      case 4:
        throw new AbortException(failedMessage);
      default:
        // This exception causes the message to appear in the Jenkins console
        throw new AbortException(failedMessage);
    }
  }

  private void setSecrets() {
    List<StringCredentials> availableSecrets = CredentialsProvider
        .lookupCredentials(StringCredentials.class, Jenkins.get(), ACL.SYSTEM, Collections.emptyList());

    for (StringCredentials stringCredentials : availableSecrets) {

      if (stringCredentials.getId().equals(portshiftSecretKeyId)) {
        this.secretKey = stringCredentials.getSecret().getPlainText();
      }

      if (stringCredentials.getId().equals(dockerRegistryPasswordId)) {
        this.dockerRegistryPassword = stringCredentials.getSecret().getPlainText();
      }
    }
  }

  // Overridden for better type safety.
  // If your plugin doesn't really define any property on Descriptor,
  // you don't have to do this.
  @Override
  public DescriptorImpl getDescriptor() {
    return (DescriptorImpl) super.getDescriptor();
  }


  /**
   * Descriptor for {@link io.jenkins.plugins.portshift_vulnerability_scanner.PortshiftVulnerabilityScannerBuilder}. Used
   * as a singleton. The class is marked as public so that it can be accessed from views.
   */
  @Symbol("portshiftVulnerabilityScanner")
  @Extension // This indicates to Jenkins that this is an implementation of an extension
  // point.
  public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {

    private static final String IP_PATTERN = "^((0|1\\d?\\d?|2[0-4]?\\d?|25[0-5]?|[3-9]\\d?)\\.){3}(0|1\\d?\\d?|2[0-4]?\\d?|25[0-5]?|[3-9]\\d?)$";


    /**
     * To persist global configuration information, simply store it in a field and call save().
     */
    private String accessKey;
    private String imageName;
    private String imageTag;
    private String url;
    private String highestSeverityAllowed;
    private String dockerRegistryUsername;
    private String highestSeverityAllowedDf;

    /**
     * In order to load the persisted global configuration, you have to call load() in the constructor.
     */
    public DescriptorImpl() {
      load();
    }

    @SuppressWarnings("unused")
    public ListBoxModel doFillDockerRegistryPasswordIdItems(@QueryParameter final String dockerRegistryPasswordId) {


      return new StandardListBoxModel()
          .includeEmptyValue()
          .includeAs(
              ACL.SYSTEM,
              Jenkins.get(),
              StringCredentials.class).includeCurrentValue(dockerRegistryPasswordId);
    }

    @SuppressWarnings("unused")
    public ListBoxModel doFillPortshiftSecretKeyIdItems(@QueryParameter final String portshiftSecretKeyId) {

      return new StandardListBoxModel()
          .includeEmptyValue()
          .includeAs(
              ACL.SYSTEM,
              Jenkins.get(),
              StringCredentials.class).includeCurrentValue(portshiftSecretKeyId);
    }


    @SuppressWarnings("ResultOfMethodCallIgnored")
    public FormValidation doCheckAccessKey(@QueryParameter final String accessKey) {
      try {
        UUID.fromString(accessKey);
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidAccesskey());
      }
    }

    public FormValidation doCheckImageName(@QueryParameter final String imageName) {
      try {
        if (!imageName.matches(IMAGE_NAME_REGEX)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageName());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageName());
      }
    }

    public FormValidation doCheckImageTag(@QueryParameter final String imageTag) {
      try {
        if (!StringUtils.isEmpty(imageTag) && !imageTag.matches(IMAGE_TAG_REGEX)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageTag());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageTag());
      }
    }

    public FormValidation doCheckUrl(@QueryParameter final String url) {
      try {
        if (!isValidUrl(url) && !isValidUrl("https://" + url)) {
          return FormValidation.error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidUrl());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation.error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidUrl());
      }
    }

    public FormValidation doCheckHighestSeverityAllowed(@QueryParameter final String highestSeverityAllowed) {
      try {
        if (!StringUtils.isEmpty(highestSeverityAllowed) && !isValidSeverity(highestSeverityAllowed)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
      }
    }

    public FormValidation doCheckHighestSeverityAllowedDf(@QueryParameter final String highestSeverityAllowedDf) {
      try {
        if (!StringUtils.isEmpty(highestSeverityAllowedDf) && !isValidSeverityDf(highestSeverityAllowedDf)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidDfSeverity());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
      }
    }

    private boolean isValidUrl(String url) {
      try {
        new URL(url);
        return true;
      } catch (MalformedURLException e) {
        return false;
      }
    }

    private boolean isValidSeverity(String severity) {
      for (VulnerabilitySeverity vulnerabilitySeverity : VulnerabilitySeverity.values()) {
        if (vulnerabilitySeverity.name().equals(severity)) {
          return true;
        }
      }
      return false;
    }

    private boolean isValidSeverityDf(String severity) {
      for (DockerRiskSeverity dockerSeverity : DockerRiskSeverity.values()) {
        if (dockerSeverity.name().equals(severity)) {
          return true;
        }
      }
      return false;
    }

    public static boolean isValidIp(final String ip) {
      return ip.matches(IP_PATTERN);
    }


    public boolean isApplicable(Class<? extends AbstractProject> aClass) {
      // Indicates that this builder can be used with all kinds of project types
      return true;
    }

    /**
     * This human readable name is used in the configuration screen.
     */
    @Override
    @Nonnull
    public String getDisplayName() {
      return Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_DisplayName();
    }

    @Override
    public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
      // To persist global configuration information,
      // set that to properties and call save().
      accessKey = formData.getString("accessKey");
      imageName = formData.getString("imageName");
      imageTag = formData.getString("imageTag");
      url = formData.getString("url");
      dockerRegistryUsername = formData.getString("dockerRegistryUsername");
      if (StringUtils.isEmpty(imageTag)) {
        imageTag = "latest";
      }
      highestSeverityAllowed = formData.getString("highestSeverityAllowed");
      highestSeverityAllowedDf = formData.getString("highestSeverityAllowedDf");
      save();
      return super.configure(req, formData);
    }

    public String getAccessKey() {
      return accessKey;
    }

    public String getImageName() {
      return imageName;
    }

    public String getImageTag() {
      return imageTag;
    }

    public String getUrl() {
      return url;
    }

    public String getHighestSeverityAllowed() {
      return highestSeverityAllowed;
    }

    public String getDockerRegistryUsername() {
      return dockerRegistryUsername;
    }

    public String getHighestSeverityAllowedDf() {
      return highestSeverityAllowedDf;
    }


  }
}
