package io.jenkins.plugins.portshift_vulnerability_scanner;


import static io.jenkins.plugins.portshift_vulnerability_scanner.PortshiftVulnerabilityScannerBuilder.PLUGIN_NAME;

import hudson.FilePath;
import hudson.Launcher;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ArgumentListBuilder;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Arrays;
import java.util.Objects;
import jenkins.model.Jenkins;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;


public class PortshiftVulnerabilityScanExecuter {

  public static final String EXEC_FILE_NAME = "securecn_deployment_cli";
  public static final String PRODUCTION_URL = "securecn.cisco.com";
  public static final String PASSWORD_MASK = "********";

  public static int execute(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener,
      String secureCnAccessKey,
      String secretKey, String imageName, String url, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf,
      Boolean pushLocalImage) {

    listener.getLogger().println(String
        .format(
            "Hello, your credentials are:%nsecureCnAccessKey: %s%nsecretKey: %s%nimageName: %s%nurl: %s%nhighestSeverityAllowed: %s%nhighestSeverityAllowedDf: %s%ndockerRegistryUsername: %s%ndockerRegistryPassword: %s%npush local image: %s%n",
            secureCnAccessKey, PASSWORD_MASK, imageName, url, highestSeverityAllowed, highestSeverityAllowedDf, dockerRegistryUsername, PASSWORD_MASK, pushLocalImage));
    try {
      ByteArrayOutputStream output = new ByteArrayOutputStream();
      int exitCode = runExecutable(launcher, listener, secureCnAccessKey, secretKey, imageName, url,
          output, highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf, pushLocalImage);
      if (exitCode == 0) {
        listener.getLogger().println("Execution succeeded.");
      } else {
        listener.getLogger().println("Execution failed.");
      }

      return exitCode;
    } catch (Exception e) {
      listener.getLogger().println("Execution failed: " + e.getMessage());
      listener.getLogger().println("Execution failed: " + Arrays.toString(e.getStackTrace()));
      return 4;
    }
  }

  private static int runExecutable(Launcher launcher, TaskListener listener,
      String secureCnAccessKey, String secretKey,
      String imageName, String url, ByteArrayOutputStream output,
      String highestSeverityAllowed, String dockerRegistryUsername, String dockerRegistryPassword,
      String highestSeverityAllowedDf, Boolean pushLocalImage)
      throws IOException, InterruptedException, URISyntaxException {
    String webappPath = Objects.requireNonNull(Jenkins.get().getPlugin(PLUGIN_NAME)).getWrapper().baseResourceURL
        .toURI().getPath();
    Launcher.ProcStarter ps = launcher.launch();

    ArgumentListBuilder args = new ArgumentListBuilder();

    String filePath = webappPath + EXEC_FILE_NAME;
    downloadDeploymentCliFile(listener, filePath, url);

    args.add(filePath).add("run-vulnerability-scan").add("--access-key")
        .add(secureCnAccessKey).add("--secret-key").add(secretKey, true).add("--image-name").add(imageName);


    if (!StringUtils.isEmpty(url)) {
      args.add("--url").add(url);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowed)) {
      args.add("--highest-severity-allowed").add(highestSeverityAllowed);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowedDf)) {
      args.add("--df-highest-severity-allowed").add(highestSeverityAllowedDf);
    }

    if (!StringUtils.isEmpty(dockerRegistryPassword) && !StringUtils.isEmpty(dockerRegistryUsername)) {
      args.add("--username").add(dockerRegistryUsername).add("--password").add(dockerRegistryPassword, true);
    }

    if (BooleanUtils.isTrue(pushLocalImage)) {
      args.add("--local").add("--push-local");
    }

    ps.cmds(args);
    ps.stdin(null);
    ps.stdout(output);
    ps.stderr(listener.getLogger());

    listener.getLogger().println("Vulnerability scan in progress...");
    int join = ps.masks(args.toMaskArray()).join();

    listener.getLogger().println(output.toString());

    return join; // RUN !
  }

  private static void downloadDeploymentCliFile(TaskListener listener, String filePath, String mgmtUrl) throws IOException {
    try {
      mgmtUrl = StringUtils.isEmpty(mgmtUrl) ? PRODUCTION_URL : mgmtUrl;
      String urlToDownloadCli = "https://" + mgmtUrl + "/tools/cli/" + EXEC_FILE_NAME;
      listener.getLogger().println("download cli: " + urlToDownloadCli);
      ReadableByteChannel readableByteChannel = Channels.newChannel(new URL(urlToDownloadCli).openStream());
      FileOutputStream fileOutputStream = new FileOutputStream(filePath);
      fileOutputStream.getChannel().transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
      fileOutputStream.close();
    } catch (Exception e) {
      listener.getLogger().println("Exception: " + e.getMessage());
      throw e;
    }
    Runtime.getRuntime().exec("chmod +x " + filePath);
  }
}
