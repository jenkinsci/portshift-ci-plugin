package io.jenkins.plugins.portshift_vulnerability_scanner;


import static io.jenkins.plugins.portshift_vulnerability_scanner.PortshiftVulnerabilityScannerBuilder.PLUGIN_NAME;

import hudson.FilePath;
import hudson.Launcher;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ArgumentListBuilder;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Arrays;
import java.util.Objects;
import jenkins.model.Jenkins;
import org.apache.commons.lang.StringUtils;


public class PortshiftVulnerabilityScanExecuter {

  public static final String EXEC_FILE_NAME = "securecn_deployment_cli";

  public static int execute(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener,
      String accessKey,
      String secretKey, String imageName, String imageTag, String url, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf) {

    listener.getLogger().println(String
        .format(
            "Hello, your credentials are:%naccessKey: %s%nsecretKey: ***%nimageName: %s%nimageTag: %s%nurl: %s%nhighestSeverityAllowed: %s%nhighestSeverityAllowedDf: %s%ndockerRegistryUsername: %s%ndockerRegistryPassword: ***",
            accessKey, imageName, imageTag, url, highestSeverityAllowed, highestSeverityAllowedDf, dockerRegistryUsername));
    try {
      ByteArrayOutputStream output = new ByteArrayOutputStream();
      int exitCode = runExecutable(launcher, listener, accessKey, secretKey, imageName, imageTag, url,
          output, highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf);
      if (exitCode == 0) {
        listener.getLogger().println("Execution succeeded.");
      } else {
        listener.getLogger().println("Execution failed.");
      }

      writeHtmlOutput(build, workspace, listener, imageName, imageTag, output);

      return exitCode;
    } catch (Exception e) {
      listener.getLogger().println("Execution failed: " + e.getMessage());
      listener.getLogger().println("Execution failed: " + Arrays.toString(e.getStackTrace()));
      return 4;
    }
  }

  private static void writeHtmlOutput(Run<?, ?> build, FilePath workspace, TaskListener listener, String imageName,
      String imageTag, ByteArrayOutputStream output) throws IOException {
    String outputFileName = imageName.replace("/", "_") + "_" + imageTag + "_output";
    File outputFile = new File(build.getRootDir(), outputFileName);
    try (FileOutputStream outputFileOutputStream = new FileOutputStream(outputFile)) {
      outputFileOutputStream.write(output.toByteArray());
    }
    FilePath latestTarget = new FilePath(workspace, "portshift_latest_scan." + "html");
    writeHtml(listener, latestTarget, output, imageName, imageTag);
  }

  private static void writeHtml(TaskListener listener, FilePath latestTarget, ByteArrayOutputStream output,
      String imageName, String imageTag) {
    String html =
        "<!DOCTYPE HTML>\n"
            + "<html lang=\"en\">\n"
            + "<head>\n"
            + "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>"
            + "<title>\n" + imageName + ":" + imageTag + "</title>\n"
            + "</head>\n"
            + "<body>\n"
            + "<h1>\n" + output.toString() + "</h1>\n"
            + "</body>\n"
            + "</html>\n"
            + "\n";
    try (FileOutputStream outputFileOutputStream = new FileOutputStream(latestTarget.getName())) {
      outputFileOutputStream.write(html.getBytes());
    } catch (Exception e) {
      listener.getLogger().println("Failed to save Portshift Vulnerability Scanner HTML report.");
    }
  }

  private static int runExecutable(Launcher launcher, TaskListener listener,
      String accessKey, String secretKey,
      String imageName, String imageTag, String url, ByteArrayOutputStream output,
      String highestSeverityAllowed, String dockerRegistryUsername, String dockerRegistryPassword,
      String highestSeverityAllowedDf)
      throws IOException, InterruptedException, URISyntaxException {
    String webappPath = Objects.requireNonNull(Jenkins.get().getPlugin(PLUGIN_NAME)).getWrapper().baseResourceURL
        .toURI().getPath();
    Launcher.ProcStarter ps = launcher.launch();

    ArgumentListBuilder args = new ArgumentListBuilder();

    String filePath = webappPath + EXEC_FILE_NAME;
    downloadDeploymentCliFile(listener, filePath, url);

    String executeFileCommand = String.format(
        "%s run-vulnerability-scan --access-key %s --secret-key %s --image-name %s --image-tag %s --url %s",
        filePath, accessKey, secretKey, imageName, imageTag, url);
    if (!StringUtils.isEmpty(highestSeverityAllowed)) {
      executeFileCommand += " --highest-severity-allowed " + highestSeverityAllowed;

    }

    if (!StringUtils.isEmpty(highestSeverityAllowedDf)) {
      executeFileCommand += " --df-highest-severity-allowed " + highestSeverityAllowedDf;
    }

    if (!StringUtils.isEmpty(dockerRegistryPassword) && !StringUtils.isEmpty(dockerRegistryUsername)) {
      executeFileCommand += " --username " + dockerRegistryUsername + " --password " + dockerRegistryPassword;
    }

    listener.getLogger().println("executing cli command: " + executeFileCommand);
    args.add("bash", "-c", executeFileCommand);
    ps.cmds(args);
    ps.stdin(null);
    ps.stdout(output);
    ps.stderr(listener.getLogger());

    listener.getLogger().println("Vulnerability scan in progress...");
    int join = ps.join();
    listener.getLogger().println(output.toString());

    return join; // RUN !
  }

  private static void downloadDeploymentCliFile(TaskListener listener, String filePath, String mgmtUrl) throws IOException {
    try {
      String urlToDownloadCli = "https://" + mgmtUrl + "/tools/cli/" + EXEC_FILE_NAME;
      listener.getLogger().println("download cli: " + urlToDownloadCli);
      ReadableByteChannel readableByteChannel = Channels.newChannel(new URL(urlToDownloadCli).openStream());
      FileOutputStream fileOutputStream = new FileOutputStream(filePath);
      fileOutputStream.getChannel().transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
      fileOutputStream.close();
    } catch (Exception e) {
      listener.getLogger().println("Exception: " + e.getMessage());
      throw e;
    }
    Runtime.getRuntime().exec("chmod +x " + filePath);
  }
}
